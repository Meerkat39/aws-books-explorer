**概要**

- **目的**: `sam build` / `sam deploy` が内部で何を実行しているかを、実行したコマンド、生成された CloudFormation リソース、そして `template.yaml` の対応箇所と照らし合わせて解説する短いメモ。
- **日付**: 2025-11-23

**コマンド → SAM 内部処理 → 作成される実リソース（要点）**

- `sam build`

  - 処理: ローカルコード（`CodeUri` で指定したフォルダ）をビルド／パッケージする。Node の場合は `package.json` を参照して依存を整理し、アーティファクトを `.aws-sam/build/` に作成する。
  - 対応 IaC: `template.yaml` の `CodeUri` をパッケージング対象として扱う。
  - 出力: `.aws-sam/build/BooksFunction`（実行アーティファクト）

- `sam deploy --guided`
  - 処理: ビルド済みアーティファクトを S3 にアップロードし、SAM が CloudFormation 用の変換テンプレートを生成して ChangeSet を作成。ユーザーが承認すると ChangeSet を適用して CloudFormation が実リソースを作成する。
  - 対応 IaC: `template.yaml` の `Resources` セクション（`AWS::Serverless::Function` など）を CloudFormation に変換して適用する。
  - 作成される主なリソース: Lambda 関数、API Gateway（REST API + /books GET）、IAM ロール（Lambda 実行用）、CloudWatch Logs、必要に応じて S3 バケット（アーティファクト格納）等。

**`template.yaml` の主要フィールドと実リソースの対応（抜粋例）**

- `Resources -> BooksFunction -> CodeUri: backend/lambda`
  - 役割: `backend/lambda` フォルダを zip 化して Lambda にデプロイするアーティファクトを作る。
- `Resources -> BooksFunction -> Handler: index.handler`
  - 役割: Lambda が呼ぶエントリポイント（`index.js` の `exports.handler`）。
- `Resources -> BooksFunction -> Runtime: nodejs18.x`
  - 役割: Lambda 実行環境を指定。
- `Resources -> BooksFunction -> Environment -> Variables -> GOOGLE_BOOKS_API_KEY: ""`
  - 役割: 環境変数の定義（値はデプロイ時に注入するか、Secrets Manager に移行する設計にする）。
- `Resources -> BooksFunction -> Events -> GetBooksApi (Type: Api)`
  - 役割: API Gateway のエンドポイント `/books`（GET）を作り、Lambda と統合する。
- `Outputs -> ApiUrl`
  - 役割: CloudFormation の Outputs に API の公開 URL を出力する（`sam deploy` が表示した `ApiUrl` に対応）。

**実行済みコマンドとマッピング（再現用）**

- ローカル検証:
  ```bash
  node backend/lambda/run_test.js   # .env があれば読み込む
  ```
- ビルド:
  ```bash
  sam build
  ```
- デプロイ:
  ```bash
  sam deploy --guided --profile dev
  ```

**デプロイ後に使う確認コマンド（具体例）**

- スタック出力（ApiUrl）を取得:
  ```bash
  aws cloudformation describe-stacks --stack-name aws-books-explorer --profile dev --region ap-northeast-1 --query 'Stacks[0].Outputs' --output table
  ```
- Lambda 設定を確認（環境変数・Role）:
  ```bash
  aws lambda get-function-configuration --function-name books-function --profile dev --region ap-northeast-1
  ```
- 作成されたリソース一覧:
  ```bash
  aws cloudformation describe-stack-resources --stack-name aws-books-explorer --profile dev --region ap-northeast-1
  ```
- ログを監視:
  ```bash
  aws logs tail /aws/lambda/books-function --follow --profile dev --region ap-northeast-1
  ```

**Secrets 管理への移行メモ（概要）**

- 方針 A（簡単）: CloudFormation の動的参照で環境変数に Secrets Manager を参照する（テンプレートに直接値を埋めずに参照）。

  - メリット: デプロイ時に安全に参照可能。簡単に移行できる。
  - 実装例（template.yaml の Environment 部分）:
    ```yaml
    Environment:
      Variables:
        GOOGLE_BOOKS_API_KEY: "{{resolve:secretsmanager:aws-books-explorer/GoogleBooks:SecretString:GOOGLE_BOOKS_API_KEY}}"
    ```
  - 注意: Lambda の実行ロールに `secretsmanager:GetSecretValue` 権限が必要。

- 方針 B（推奨）: Lambda 内で Secrets Manager SDK を呼んで `GetSecretValue` で取得する。
  - メリット: Secrets の更新をアプリ側で柔軟に扱える（複数キーや JSON 形式に対応）。
  - 実装の流れ: `template.yaml` に Secret 名を環境変数で渡す → Lambda 起動時に SDK で取得。

**注意点（運用上のチェックリスト）**

- 公開 API のまま運用しない: テストでは可だが、本番は API Key / Cognito / Authorizer で制限を必須にする。\
- コスト管理: CloudFormation 自体は無料だが、Lambda 実行・API Gateway リクエスト・CloudWatch Logs 等が課金対象。テスト後は `sam delete` でスタックを削除する。
- 秘密情報の扱い: ローカルの `.env` はリポジトリに含めない。既に公開してしまったらキーをローテーションする。

**簡単な次のアクション（選択肢）**

- A: `template.yaml` を Secrets Manager 参照に変更するパッチを作成する（私が作ります）。
- B: API を簡易保護する（API Key + Usage Plan）を `template.yaml` に追加するパッチを作成する。
- C: 今はそのまま手動で Google API キーを Lambda に注入して動作確認する（CLI コマンドを使う）。

---

